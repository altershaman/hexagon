hexF:

# converted entities final assembly
  toHexNodes: >
    (
      $parties:= $eval($$.hexF.partiesToParty_ttl);
      $products:= $eval($$.hexF.productsToProduct_ttl);
      $processes:= $eval($$.hexF.processesToProcess_ttl);
      $requirements:= $eval($$.hexF.requirementsToRequirement_ttl);

      $capabilities:= $eval($$.hexF.capabilitiesToCapability_ttl);
      $bapies:= $eval($$.hexF.bapiesToBapi_ttl);

      $accum:= $append($parties, $products);
      $accum:= $append($accum, $processes);
      $accum:= $append($accum, $requirements);

      $accum:= $append($accum, $capabilities);
      $accum:= $append($accum, $bapies);
    )

  toHexEdges: >
    (
      $supports:= $eval($$.hexF.dh_componentsToHex);
      $fromParties:= $eval($$.hexF.partiesToEdges);
      $fromProducts:= $eval($$.hexF.productsToEdges);
      $fromProcesses:= $eval($$.hexF.processesToEdges);

      $fromCapabilities:= $eval($$.hexF.capabilitiesToEdges);
      $fromBapies:= $eval($$.hexF.bapiesToEdges);

      $accum:= $append($fromParties, $fromProducts);
      $accum:= $append($accum, $fromProcesses);
      $accum:= $append($accum, $supports);

      $accum:= $append($accum, $fromCapabilities);
      $accum:= $append($accum, $fromBapies);
    )

# from KADZO to Hex Converters
  partiesToParty_ttl: >
    (
      $kadzo_parties:= $$."seaf.ba.parties".$spread();
      $map($kadzo_parties, function($v){
        { "id": $keys($v),
          "body": $v.* 
        }
      })
    )
#todo добавить конвертацию reports
  partiesToEdges: >
    (
      $kadzo_parties:= $$."seaf.ba.parties".$spread();
      $reduce([$map($kadzo_parties, function($v){(
        
        $maps:= {
          "source": $keys($v),
          "target": "mm.party",
          "label": "map"
        };

        $interested:= $v.*.has_interest;
        $interested:= $map($interested, function($vv) {
          { "source": $keys($v),
            "target": $vv,
            "label":"" 
          }
        });



        $relates:= $v.*.relates;
        $relates:= $map($relates, function($vv) {
          { "source": $keys($v),
            "target": $vv,
            "label":"" 
          }
        });

        $converted:= $append($interested, $relates);
        $append($converted, $maps);
      )})], $append)
    )

  productsToProduct_ttl: >
    (
      $kadzo_products:= $$."seaf.ba.products".$spread();
      $map($kadzo_products, function($v){
        { "id": $keys($v),
          "body": $v.* 
        }
      })
    )

  productsToEdges: >
    (
      $kadzo_products:= $$."seaf.ba.products".$spread();
      $reduce([$map($kadzo_products, function($v){(

      $maps:= {
          "source": $keys($v),
          "target": "mm.product",
          "label": "map"
        };

        
        $owner:= $v.*.owner;
        $owner:= {"source": $keys($v),
                  "target": $owner,
                  "label":"" 
                 };

        $used:= $v.*.used_in;
        $used:= $map($used, function($vv) {
          { "source": $keys($v),
            "target": $vv,
            "label":"" 
          }
        });

        $converted:= $append($owner, $used);
        $append($converted, $maps);
      )})], $append)
    )

  processesToProcess_ttl: >
    (
      $seaf_core_processes:= $$."seaf.ba.processes".$spread();
      $map($seaf_core_processes, function($v){
        { "id": $keys($v),
          "body": $v.* 
        }
      })
    )

  processesToEdges: >
    (
      $seaf_core_processes:= $$."seaf.ba.processes".$spread();
      $reduce([$map($seaf_core_processes, function($v){(

      $maps:= {
          "source": $keys($v),
          "target": "mm.process",
          "label": "map"
        };
        
        $owner:= $v.*.owner;
        $owner:= $owner != null ? {"source": $keys($v),
                                    "target": $owner,
                                    "label":"владелец" 
                                  };
                                  
        $hi_process:= $v.*.relates;
        $hi_process:= $hi_process != null ? {"source": $keys($v),
                                                "target": $hi_process,
                                                "label":"относится к" 
                                            };

        $next:= $v.*.next_processes;
        $next:= $map($next, function($vv) {
          { "source": $keys($v),
            "target": $vv,
            "label":"поток работ" 
          }
        });

        $automated:= $v.*.systems;
        $automated:= $map($automated, function($vv) {
          { "target": $keys($v),
            "source": $vv,
            "label":"поддерживает" 
          }
        });

        $reqs:= $v.*.requirements;
        $reqs:= $map($reqs, function($vv) {
          { "source": $keys($v),
            "target": $vv,
            "label": "требует"
          }
        });


        $converted:= $append($maps, $owner);
        $converted:= $append($converted, $hi_process);
        $converted:= $append($converted, $next);
        $converted:= $append($converted, $automated);
        $converted:= $append($converted, $reqs);
      )})], $append)
    )

  requirementsToRequirement_ttl: >
    (
      $seaf_core_requirements:= $$."seaf.change.requirements".$spread();
      $map($seaf_core_requirements, function($v){
        { "id": $keys($v),
          "body": $v.* 
        }
      })
    )

  requirementsToEdges: >
    (
      $seaf_core_requirements:= $$."seaf.change.requirements".$spread();
      $map($seaf_core_requirements, function($v) {
        $maps:= {
                  "source": $keys($v),
                  "target": "mm.requirement",
                  "label": "map"
                }
      })
    )


# from BBB to hex converters

  capabilitiesToCapability_ttl: >
    (
      $seaf_bbb_capabilities:= $$."seaf.bbb.capabilities".$spread();
      $map($seaf_bbb_capabilities, function($v){
        { "id": $keys($v),
          "body": $v.* 
        }
      })
    )

  capabilitiesToEdges: >
    (
      $seaf_bbb_capabilities:= $$."seaf.bbb.capabilities".$spread();
      $reduce([$map($seaf_bbb_capabilities, function($v){(

      $maps:= {
          "source": $keys($v),
          "target": "mm.capability",
          "label": "map"
        };
        
        
        $owner:= $v.*.owner;
        $owner:= $owner != null ? {"source": $keys($v),
                                    "target": $owner,
                                    "label":"владелец" 
                                  };
                                  
        $hi_cap:= $v.*.relates;
        $hi_cap:= $hi_cap != null ? {"source": $keys($v),
                                        "target": $hi_cap,
                                        "label":"относится к" 
                                    };

        $api_used:= $v.*.use_b_apies;
        $api_used:= $map($api_used, function($vv) {
          { "source": $keys($v),
            "target": $vv,
            "label":"использует" 
          }
        });

        $process_comp:= $v.*.composed_of;
        $process_comp:= $map($process_comp, function($vv) {
          { "source": $vv,
            "target": $keys($v),
            "label":"исполняется в" 
          }
        });

        $converted:= $append($maps, $owner);
        $converted:= $append($converted, $hi_cap);
        $converted:= $append($converted, $api_used);
        $converted:= $append($converted, $process_comp);

      )})], $append)

    )

  bapiesToBapi_ttl: >
    (
      $seaf_bbb_bapies:= $$."seaf.bbb.b_api".$spread();
      $map($seaf_bbb_bapies, function($v){
        { "id": $keys($v),
          "body": $v.* 
        }
      })
    )

  bapiesToEdges: >
    (
      $seaf_bbb_bapies:= $$."seaf.bbb.b_api".$spread();
      $reduce([$map($seaf_bbb_bapies, function($v){(

      $maps:= {
          "source": $keys($v),
          "target": "mm.bapi",
          "label": "map"
        };
        
                $hi_cap:= $v.*.relates;
        $hi_cap:= $hi_cap != null ? {"source": $keys($v),
                                     "target": $hi_cap,
                                     "label":"предоставляется" 
                                    };

        $converted:= $append($maps, $hi_cap);
      )})], $append)

    )

# Translation app layer objects links into hex
# todo разбить на две функции как у остальных сущностей
  dh_componentsToHex: >
    (
      $components:= $$.components.$spread()[$.*.entity="component"];
      $reduce($map($components, function($v) {(
        $maps:= [
          {"source": $keys($v), "target": "mm.resource", "label": "map"},
          {"source": $keys($v), "target": "mm.resource.app_service", "label": "type"}];
        $regs:= $map($v.*.processes, function($vv) {
          {"source": $keys($v), "target": $vv, "label": "поддерживает"}
        });
        $regs2:= $map($v.*.requirements, function($vv) {
          {"source": $keys($v), "target": $vv, "label": "обеспечивает"}
        });
        $regs:= $append($regs, $regs2);
        $append($maps, $regs);
      )}), $append)
    )
